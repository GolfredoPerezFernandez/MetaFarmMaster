
//START: CONNECTING TO MORALIS
const CONTRACT_ADDRESS = "0xe431308cE602Ff13d23e82e92a1fbE0DC2826Ab5";
const FRONTEND_BASE_URL = "http://localhost:3000/";


const serverUrl = "https://metafarmlands.herokuapp.com/server";
const appId = '001';
Moralis.start({
	serverUrl,
	appId,
  });
  
   
//END: CONNECTING TO MORALIS
//START: LOAD METADATA 
	   

let ALL_METADATA = [];
function getAllMetaData() {
  let httpRequest = new XMLHttpRequest(); // asynchronous request
  httpRequest.open("GET", "ALL_METADATA.json", true);
  httpRequest.send();
  httpRequest.addEventListener("readystatechange", function () {
    if (this.readyState === this.DONE) {
      // when the request has completed
      ALL_METADATA = JSON.parse(this.response);
    }
  });
}
async function init(){

await Moralis.enableWeb3();

console.log('initializing')

const { message } = await Moralis.Cloud.run('getAllTokenIds')
  console.log('initiate login '+message);


}

getAllMetaData();
//END: LOAD METADATA

let TOKEN_IDS = [];

//
function fetchNFTMetaData(NFTs) {
	// let promises = [];
	let result = [];
	TOKEN_IDS = [];
	for (let i = 0; i < NFTs.length; i++) {
	  let nft = NFTs[i];
	  let id = nft.token_id;
  
	  nft.metadata = ALL_METADATA.find(x => x.id === Number(id));
	  result.push(nft);
  
	  TOKEN_IDS.push(id);
	  //Moralis cloud function to avoid cors;
	  //"https://sbimlknlimqd.usemoralis.com:2053/server/functions/getNFT?_ApplicationId=EKUj1USRVYPzjZu83lUO9oqYf5M4mDyY27d5BRxd&nftId=" + id
	//   promises.push(
	//     fetch(`${serverUrl}/functions/getNFT?_ApplicationId=${appId}&nftId=${id}`)
	//       .then(response => response.json())
	//       .then(response => JSON.parse(response.result))
	//       .then(response => { nft.metadata = response })
	//       .then(() => { return nft })
	//   );
	}
	// return Promise.all(promises);
	return result;
  }
//
 async function parseNFTStatus(NFTs, marketItems) {
  let user = Moralis.User.current();
  let account;
  if (user) {
    account = user.get("accounts")[0];
  }
  let result = [];
  await NFTs.map(async  (n) => {
    let r = marketItems.slice().reverse().find(
      (e) =>
        e.token_address === n?.token_address &&
        e.token_id === n?.token_id
    );
   await result.push({ ...n, ...r});
  });
  return result;
}

const CONTRACT_ABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "account",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "burn",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "nftContractAddress",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "marketItemId",
				"type": "uint256"
			}
		],
		"name": "cancelMarketItem",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "nftContract",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "price",
				"type": "uint256"
			}
		],
		"name": "createMarketItem",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "nftContract",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "tokenIds",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "prices",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"name": "createMarketItemBatch",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "itemId",
				"type": "uint256"
			}
		],
		"name": "createMarketSale",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "itemId",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "nftContract",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "seller",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "price",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "sold",
				"type": "bool"
			}
		],
		"name": "MarketItemCreated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "itemId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "price",
				"type": "uint256"
			}
		],
		"name": "MarketItemSold",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "ids",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"name": "mintBatch",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "onERC1155BatchReceived",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "",
				"type": "bytes4"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "onERC1155Received",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "",
				"type": "bytes4"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "ids",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "safeBatchTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_wallet1",
				"type": "address"
			}
		],
		"name": "setAddress1",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_wallet2",
				"type": "address"
			}
		],
		"name": "setAddress2",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "setApprovalForAll",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256[]",
				"name": "ids",
				"type": "uint256[]"
			},
			{
				"indexed": false,
				"internalType": "uint256[]",
				"name": "values",
				"type": "uint256[]"
			}
		],
		"name": "TransferBatch",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "TransferSingle",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "value",
				"type": "string"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "URI",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address[]",
				"name": "accounts",
				"type": "address[]"
			},
			{
				"internalType": "uint256[]",
				"name": "ids",
				"type": "uint256[]"
			}
		],
		"name": "balanceOfBatch",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_tokenId",
				"type": "uint256"
			}
		],
		"name": "fetchItem",
		"outputs": [
			{
				"components": [
					{
						"internalType": "uint256",
						"name": "itemId",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "nftContract",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "tokenId",
						"type": "uint256"
					},
					{
						"internalType": "address payable",
						"name": "seller",
						"type": "address"
					},
					{
						"internalType": "address payable",
						"name": "owner",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "price",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "sold",
						"type": "bool"
					},
					{
						"internalType": "bool",
						"name": "cancel",
						"type": "bool"
					}
				],
				"internalType": "struct NFTContract.MarketItem",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "fetchMarketItems",
		"outputs": [
			{
				"components": [
					{
						"internalType": "uint256",
						"name": "itemId",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "nftContract",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "tokenId",
						"type": "uint256"
					},
					{
						"internalType": "address payable",
						"name": "seller",
						"type": "address"
					},
					{
						"internalType": "address payable",
						"name": "owner",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "price",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "sold",
						"type": "bool"
					},
					{
						"internalType": "bool",
						"name": "cancel",
						"type": "bool"
					}
				],
				"internalType": "struct NFTContract.MarketItem[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "isApprovedForAll",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes4",
				"name": "interfaceId",
				"type": "bytes4"
			}
		],
		"name": "supportsInterface",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "uri",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "wallet1",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "wallet2",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
]
const getMarketItem = async (nft) => {
	
const sendOptions2 = {
	contractAddress: "0xe431308cE602Ff13d23e82e92a1fbE0DC2826Ab5",
	functionName: "fetchItem",
  //	  msgValue: Moralis.Units.ETH("0"),
	abi: CONTRACT_ABI,
	awaitReceipt: true ,// should be switched to false
	params: {				
		_tokenId: nft.token_id
	},
  
  };
		let res= await Moralis.executeFunction(sendOptions2)
		
result=res

	return result;
}

async function getAllTokenIds() {
  let cursor = null;  
  const OPTIONS = { address: CONTRACT_ADDRESS, chain: '0x61' }

  let NFTs = [];
  do {
	console.log('response ')
    let response = await Moralis.Web3API.token.getAllTokenIds(OPTIONS);
  console.log('response '+response)
	
	NFTs.push(response.result);
    cursor = response.cursor
  } while(cursor !== "" && cursor != null);

  return { result: NFTs.flat() }
}


// Get all NFTs
async function loadInventory() {
	console.log( ' NFTs');
	
	let NFTs = await getAllTokenIds();
	console.log(NFTs, 'pure NFTs');
  
	let NFTsWithMetadata = await fetchNFTMetaData(NFTs.result);
  
	//Get market items
	const createdMarketItemsObject = Moralis.Object.extend("BinancelandsLogs");
	const query = new Moralis.Query(createdMarketItemsObject);
	query.limit(100000000);
	const createdMarketItems = await query.find();
	const CreatedMarketItems = createdMarketItems.map(x => x.attributes);
	console.log(CreatedMarketItems, 'BinancelandsLogs');
	const NFTsWithMetadataParsed = parseNFTStatus(NFTsWithMetadata, CreatedMarketItems);
	console.log(NFTsWithMetadataParsed, 'parsed');
  
	return NFTsWithMetadataParsed;
  }

const slicedWallet = (address) => {
  if (address === '0x0000000000000000000000000000000000000000') {
    return 'Marketplace';
  }
  if (address) {
    return address.slice(0, 7) + '...' + address.slice(address.length - 5, address.length);
  } else {
    return "Not available";
  }
}

const metadataToPopup =async (nft) => {
	
	let res=await  getMarketItem(nft)
	let sold=true
	if(parseFloat(res[5])!==0){
		sold=false
	}
  let metadata = nft.metadata;
  let buttonText = sold ? 'Visit page' : 'Buy Now';
  let price = sold  ? '' : `<div><b>Price:</b> ${parseFloat(res[5]) / ("1e" + 18)} BNB</div>`;
  let image = `<img style="width:300px;" src="${metadata?.image}"/>`;
  return `<div style="display:flex;flex-direction:column"> ${image} <b>${metadata?.name}</b> <div>${metadata?.description}</div> <div><b>Owner:</b> ${slicedWallet(res[3])}</div> ${price} <button onclick="window.open('${FRONTEND_BASE_URL}nft/${nft.token_id}','_blank')">${buttonText}</button></div>`;
};

const calculateColor =async (inventoryItem) => { 
	let res=await  getMarketItem(inventoryItem)
	let sold=false      
	let user = Moralis.User.current();

	let account = user.get("accounts")[0];

	if(res[3].toLowerCase()=== account.toLowerCase()){
		sold=true
	}
  let color = res[3].toLowerCase()!=="0x0000000000000000000000000000000000000000" ? '#DEEBFF' :
    sold ? '#000000' : '#336699';
  return color;
}

const getInventoryItemById = (inventory, inventoryItemId) => {
	

  let result = inventory.find(({ token_id }) => token_id === String(inventoryItemId));
	
  return result;
}

